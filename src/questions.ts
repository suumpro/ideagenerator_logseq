import '@logseq/libs';
import { AdvancedMethodologies, QuantityToQuality } from './methodologies';

interface QuestionPack {
  name: string;
  questions: string[] | ((_previousAnswer?: string, _depth?: number) => string);
  onComplete?: (_answers: string[]) => string;
  maxDepth?: number;
}

export class QuestionFramework {
  private questionPacks: Map<string, QuestionPack> = new Map();
  private advancedMethodologies: AdvancedMethodologies;
  private quantityChecker: QuantityToQuality;

  constructor() {
    this.initializeQuestionPacks();
    this.advancedMethodologies = new AdvancedMethodologies();
    this.quantityChecker = new QuantityToQuality();
  }

  private initializeQuestionPacks() {
    this.questionPacks.set('JTBD', {
      name: 'Jobs to be Done',
      questions: [
        "이 아이디어는 누구를 위한 건가요?",
        "어떤 상황에서 필요한 건가요?", 
        "성공은 어떻게 측정할 수 있을까요?"
      ],
      onComplete: (answers) => {
        return `## Jobs to be Done Analysis
- **타겟 사용자**: ${answers[0]}
- **사용 상황**: ${answers[1]}
- **성공 지표**: ${answers[2]}

*Generated by Seed Plugin*`;
      }
    });

    this.questionPacks.set('FiveWhys', {
      name: 'Five Whys',
      questions: (previousAnswer?: string, depth?: number) => {
        if (depth === 0) return "왜 이 문제가 발생하나요?";
        const preview = previousAnswer?.slice(0, 30) + '...';
        return `"${preview}" → 왜 그런가요?`;
      },
      maxDepth: 5,
      onComplete: (answers) => {
        let result = '## Five Whys Analysis\n';
        answers.forEach((answer, index) => {
          result += `${index + 1}. **Why**: ${answer}\n`;
        });
        result += '\n*Root cause analysis completed*';
        return result;
      }
    });

    this.questionPacks.set('SCAMPER', {
      name: 'SCAMPER Method',
      questions: [
        "**Substitute**: 무엇을 대체할 수 있을까요?",
        "**Combine**: 무엇과 결합할 수 있을까요?",
        "**Adapt**: 무엇에 적용할 수 있을까요?",
        "**Modify**: 어떻게 수정/확대할 수 있을까요?",
        "**Put to other use**: 다른 용도는 무엇일까요?",
        "**Eliminate**: 무엇을 제거/단순화할 수 있을까요?",
        "**Reverse**: 반대로 하면 어떨까요?"
      ],
      onComplete: (answers) => {
        return `## SCAMPER Analysis
${answers.map((answer, i) => {
  const letters = ['S', 'C', 'A', 'M', 'P', 'E', 'R'];
  return `- **${letters[i]}**: ${answer}`;
}).join('\n')}

*Creative exploration completed*`;
      }
    });
  }

  async startQuestionFlow(block: any) {
    // Check for quantity-to-quality upgrade first
    const qualityUpgrade = await this.quantityChecker.checkForQualityUpgrade(block.uuid);
    if (qualityUpgrade) return;

    // Smart methodology selection
    const suggestedFramework = this.advancedMethodologies.getMethodologyForContext(
      block.content, 
      block.properties
    );
    
    const framework = logseq.settings?.questionFramework === 'Auto' 
      ? suggestedFramework 
      : (logseq.settings?.questionFramework || 'JTBD');

    // Try advanced methodologies first
    const methodology = this.advancedMethodologies.getMethodology(framework);
    if (methodology) {
      await this.startAdvancedQuestionFlow(block, methodology);
      return;
    }

    // Fallback to basic question packs
    const questionPack = this.questionPacks.get(framework);
    if (!questionPack) {
      logseq.UI.showMsg('알 수 없는 질문 프레임워크입니다.', 'error');
      return;
    }

    await logseq.Editor.upsertBlockProperty(block.uuid, 'seed-status', 'questioning');
    await logseq.Editor.upsertBlockProperty(block.uuid, 'seed-framework', framework);
    await this.askNextQuestion(block.uuid, questionPack, 0, []);
  }

  private async startAdvancedQuestionFlow(block: any, methodology: any) {
    await logseq.Editor.upsertBlockProperty(block.uuid, 'seed-status', 'questioning');
    await logseq.Editor.upsertBlockProperty(block.uuid, 'seed-methodology', methodology.name);
    await logseq.Editor.upsertBlockProperty(block.uuid, 'seed-stage', methodology.stages[0]);

    // Start with first stage questions
    const questions = typeof methodology.questions.questions === 'function' 
      ? methodology.questions.questions({ currentStage: 0 })
      : methodology.questions.questions;

    await this.askAdvancedQuestion(block.uuid, methodology, 0, 0, []);
  }

  private async askAdvancedQuestion(
    parentUuid: string,
    methodology: any,
    stageIndex: number,
    questionIndex: number,
    stageAnswers: string[]
  ) {
    const questions = typeof methodology.questions.questions === 'function'
      ? methodology.questions.questions({ currentStage: stageIndex })
      : methodology.questions.questions;

    if (questionIndex >= questions.length) {
      // Move to next stage or complete
      if (stageIndex + 1 < methodology.stages.length) {
        await this.askAdvancedQuestion(parentUuid, methodology, stageIndex + 1, 0, []);
      } else {
        await this.completeAdvancedFlow(parentUuid, methodology, stageAnswers);
      }
      return;
    }

    const question = questions[questionIndex];
    const stageName = methodology.stages[stageIndex];

    const questionBlock = await logseq.Editor.insertBlock(
      parentUuid,
      `#seed/question **${stageName}**: ${question}`,
      {
        properties: {
          'seed-methodology': methodology.name,
          'seed-stage': stageName,
          'seed-question-index': `${stageIndex}-${questionIndex}`
        },
        sibling: false
      }
    );

    const answerBlock = await logseq.Editor.insertBlock(
      questionBlock.uuid,
      '답변: ',
      { sibling: false }
    );

    this.waitForAdvancedAnswer(answerBlock.uuid, parentUuid, methodology, stageIndex, questionIndex, stageAnswers);
  }

  private waitForAdvancedAnswer(
    answerUuid: string,
    parentUuid: string,
    methodology: any,
    stageIndex: number,
    questionIndex: number,
    stageAnswers: string[]
  ) {
    const checkAnswer = async () => {
      const answerBlock = await logseq.Editor.getBlock(answerUuid);
      const content = answerBlock?.content || '';
      
      if (content.replace('답변:', '').trim().length > 3) {
        const answer = content.replace('답변:', '').trim();
        const newStageAnswers = [...stageAnswers, answer];
        
        setTimeout(() => {
          this.askAdvancedQuestion(parentUuid, methodology, stageIndex, questionIndex + 1, newStageAnswers);
        }, 1000);
        
        return true;
      }
      
      setTimeout(checkAnswer, 2000);
      return false;
    };

    setTimeout(checkAnswer, 2000);
  }

  private async completeAdvancedFlow(parentUuid: string, methodology: any, allAnswers: string[]) {
    await logseq.Editor.upsertBlockProperty(parentUuid, 'seed-status', 'developed');
    
    if (methodology.onComplete) {
      const summary = methodology.onComplete(allAnswers);
      await logseq.Editor.insertBlock(
        parentUuid,
        summary,
        {
          properties: {
            'seed-analysis': methodology.name,
            'seed-completed': new Date().toISOString()
          },
          sibling: false
        }
      );
    }

    // Suggest next methodologies
    const suggestions = await this.advancedMethodologies.suggestNextMethodology(
      methodology.name, 
      await logseq.Editor.getBlock(parentUuid)
    );

    if (suggestions.length > 0) {
      logseq.UI.showMsg(
        `✅ ${methodology.name} 완료! 다음 방법론을 추천합니다:`,
        'info',
        {
          actions: suggestions.map(method => ({
            label: method,
            onClick: () => this.startMethodology(parentUuid, method)
          }))
        }
      );
    }
  }

  private async startMethodology(seedUuid: string, methodologyName: string) {
    const methodology = this.advancedMethodologies.getMethodology(methodologyName);
    if (methodology) {
      const block = await logseq.Editor.getBlock(seedUuid);
      await this.startAdvancedQuestionFlow(block, methodology);
    }
  }

  private async askNextQuestion(
    parentUuid: string, 
    questionPack: QuestionPack, 
    questionIndex: number, 
    previousAnswers: string[]
  ) {
    let question: string;
    
    if (Array.isArray(questionPack.questions)) {
      if (questionIndex >= questionPack.questions.length) {
        // All questions answered, complete the framework
        await this.completeQuestionFlow(parentUuid, questionPack, previousAnswers);
        return;
      }
      question = questionPack.questions[questionIndex];
    } else {
      if (questionPack.maxDepth && questionIndex >= questionPack.maxDepth) {
        await this.completeQuestionFlow(parentUuid, questionPack, previousAnswers);
        return;
      }
      const lastAnswer = previousAnswers[previousAnswers.length - 1];
      question = questionPack.questions(lastAnswer, questionIndex);
    }

    // Create question block
    const questionBlock = await logseq.Editor.insertBlock(
      parentUuid,
      `#seed/question ${question}`,
      {
        properties: {
          'seed-question-type': questionPack.name,
          'seed-question-index': questionIndex.toString(),
          'seed-question-framework': questionPack.name
        },
        sibling: false
      }
    );

    // Create answer block and focus on it
    const answerBlock = await logseq.Editor.insertBlock(
      questionBlock.uuid,
      '답변: ',
      { sibling: false }
    );

    // Set up listener for answer completion
    this.waitForAnswer(answerBlock.uuid, parentUuid, questionPack, questionIndex, previousAnswers);
  }

  private waitForAnswer(
    answerUuid: string,
    parentUuid: string,
    questionPack: QuestionPack,
    questionIndex: number,
    previousAnswers: string[]
  ) {
    // Set up a periodic check for answer completion
    const checkAnswer = async () => {
      const answerBlock = await logseq.Editor.getBlock(answerUuid);
      const content = answerBlock?.content || '';
      
      // Check if answer has substance (more than just "답변: ")
      if (content.replace('답변:', '').trim().length > 3) {
        const answer = content.replace('답변:', '').trim();
        const newAnswers = [...previousAnswers, answer];
        
        // Ask next question
        setTimeout(() => {
          this.askNextQuestion(parentUuid, questionPack, questionIndex + 1, newAnswers);
        }, 1000);
        
        return true; // Stop checking
      }
      
      // Continue checking if no substantial answer yet
      setTimeout(checkAnswer, 2000);
      return false;
    };

    // Start checking after a short delay
    setTimeout(checkAnswer, 2000);
  }

  private async completeQuestionFlow(
    parentUuid: string,
    questionPack: QuestionPack,
    answers: string[]
  ) {
    // Update parent block status
    await logseq.Editor.upsertBlockProperty(parentUuid, 'seed-status', 'developed');
    await logseq.Editor.upsertBlockProperty(parentUuid, 'seed-stage', 'define');

    // Generate completion summary if available
    if (questionPack.onComplete) {
      const summary = questionPack.onComplete(answers);
      
      await logseq.Editor.insertBlock(
        parentUuid,
        summary,
        {
          properties: {
            'seed-analysis': questionPack.name,
            'seed-completed': new Date().toISOString()
          },
          sibling: false
        }
      );
    }

    // Show completion message
    logseq.UI.showMsg(
      `✅ ${questionPack.name} 분석이 완료되었습니다!`,
      'success'
    );

    // Suggest next steps
    setTimeout(() => {
      this.suggestNextSteps(parentUuid);
    }, 2000);
  }

  private async suggestNextSteps(blockUuid: string) {
    logseq.UI.showMsg(
      '🚀 다음 단계를 추천합니다:',
      'info',
      {
        actions: [
          {
            label: '프로젝트 생성',
            onClick: () => this.createProject(blockUuid)
          },
          {
            label: '더 많은 질문',
            onClick: () => this.addMoreQuestions(blockUuid)
          },
          {
            label: '관련 아이디어 찾기',
            onClick: () => this.findRelatedIdeas(blockUuid)
          }
        ]
      }
    );
  }

  private async createProject(seedUuid: string) {
    const { ProjectTemplates } = await import('./templates');
    const templates = new ProjectTemplates();
    await templates.createProjectFromSeed(seedUuid);
  }

  private async addMoreQuestions(seedUuid: string) {
    const frameworks = Array.from(this.questionPacks.keys());
    const currentFramework = logseq.settings?.questionFramework || 'JTBD';
    const nextFramework = frameworks[(frameworks.indexOf(currentFramework) + 1) % frameworks.length];
    
    const nextPack = this.questionPacks.get(nextFramework);
    
    if (nextPack) {
      await this.askNextQuestion(seedUuid, nextPack, 0, []);
    }
  }

  private async findRelatedIdeas(seedUuid: string) {
    const block = await logseq.Editor.getBlock(seedUuid);
    const keywords = this.extractKeywords(block.content);
    
    // Simple keyword-based search
    const related = await logseq.DB.q(`
      [:find (pull ?b [*])
       :where
       [?b :block/content ?content]
       [?b :block/properties ?props]
       [(get ?props :seed-status) ?status]
       [(re-find #"${keywords.join('|')}" ?content)]]
    `);

    if (related.length > 1) { // Exclude self
      await logseq.Editor.insertBlock(
        seedUuid,
        `## 관련 아이디어들`,
        { sibling: false }
      );

      for (const relatedBlock of related) {
        if (relatedBlock.uuid !== seedUuid) {
          await logseq.Editor.insertBlock(
            seedUuid,
            `- ((${relatedBlock.uuid}))`,
            { sibling: false }
          );
        }
      }
    }
  }

  private extractKeywords(content: string): string[] {
    // Simple keyword extraction (can be improved with NLP)
    const words = content
      .replace(/#\w+/g, '') // Remove tags
      .replace(/[^\w\s가-힣]/g, ' ') // Keep only words and Korean
      .split(/\s+/)
      .filter(word => word.length > 2);
    
    return [...new Set(words)].slice(0, 5); // Return unique words, max 5
  }
}