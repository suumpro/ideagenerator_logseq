import '@logseq/libs';

interface QuestionPack {
  name: string;
  questions: string[] | ((previousAnswer?: string, depth?: number) => string);
  onComplete?: (answers: string[]) => string;
  maxDepth?: number;
}

export class QuestionFramework {
  private questionPacks: Map<string, QuestionPack> = new Map();

  constructor() {
    this.initializeQuestionPacks();
  }

  private initializeQuestionPacks() {
    this.questionPacks.set('JTBD', {
      name: 'Jobs to be Done',
      questions: [
        "이 아이디어는 누구를 위한 건가요?",
        "어떤 상황에서 필요한 건가요?", 
        "성공은 어떻게 측정할 수 있을까요?"
      ],
      onComplete: (answers) => {
        return `## Jobs to be Done Analysis
- **타겟 사용자**: ${answers[0]}
- **사용 상황**: ${answers[1]}
- **성공 지표**: ${answers[2]}

*Generated by Seed Plugin*`;
      }
    });

    this.questionPacks.set('FiveWhys', {
      name: 'Five Whys',
      questions: (previousAnswer?: string, depth?: number) => {
        if (depth === 0) return "왜 이 문제가 발생하나요?";
        const preview = previousAnswer?.slice(0, 30) + '...';
        return `"${preview}" → 왜 그런가요?`;
      },
      maxDepth: 5,
      onComplete: (answers) => {
        let result = '## Five Whys Analysis\n';
        answers.forEach((answer, index) => {
          result += `${index + 1}. **Why**: ${answer}\n`;
        });
        result += '\n*Root cause analysis completed*';
        return result;
      }
    });

    this.questionPacks.set('SCAMPER', {
      name: 'SCAMPER Method',
      questions: [
        "**Substitute**: 무엇을 대체할 수 있을까요?",
        "**Combine**: 무엇과 결합할 수 있을까요?",
        "**Adapt**: 무엇에 적용할 수 있을까요?",
        "**Modify**: 어떻게 수정/확대할 수 있을까요?",
        "**Put to other use**: 다른 용도는 무엇일까요?",
        "**Eliminate**: 무엇을 제거/단순화할 수 있을까요?",
        "**Reverse**: 반대로 하면 어떨까요?"
      ],
      onComplete: (answers) => {
        return `## SCAMPER Analysis
${answers.map((answer, i) => {
  const letters = ['S', 'C', 'A', 'M', 'P', 'E', 'R'];
  return `- **${letters[i]}**: ${answer}`;
}).join('\n')}

*Creative exploration completed*`;
      }
    });
  }

  async startQuestionFlow(block: any) {
    const framework = logseq.settings?.questionFramework || 'JTBD';
    const questionPack = this.questionPacks.get(framework);
    
    if (!questionPack) {
      logseq.UI.showMsg('알 수 없는 질문 프레임워크입니다.', 'error');
      return;
    }

    // Update block status
    await logseq.Editor.upsertBlockProperty(block.uuid, 'seed-status', 'questioning');
    await logseq.Editor.upsertBlockProperty(block.uuid, 'seed-framework', framework);

    // Start the question sequence
    await this.askNextQuestion(block.uuid, questionPack, 0, []);
  }

  private async askNextQuestion(
    parentUuid: string, 
    questionPack: QuestionPack, 
    questionIndex: number, 
    previousAnswers: string[]
  ) {
    let question: string;
    
    if (Array.isArray(questionPack.questions)) {
      if (questionIndex >= questionPack.questions.length) {
        // All questions answered, complete the framework
        await this.completeQuestionFlow(parentUuid, questionPack, previousAnswers);
        return;
      }
      question = questionPack.questions[questionIndex];
    } else {
      if (questionPack.maxDepth && questionIndex >= questionPack.maxDepth) {
        await this.completeQuestionFlow(parentUuid, questionPack, previousAnswers);
        return;
      }
      const lastAnswer = previousAnswers[previousAnswers.length - 1];
      question = questionPack.questions(lastAnswer, questionIndex);
    }

    // Create question block
    const questionBlock = await logseq.Editor.insertBlock(
      parentUuid,
      `#seed/question ${question}`,
      {
        properties: {
          'seed-question-type': questionPack.name,
          'seed-question-index': questionIndex.toString(),
          'seed-question-framework': questionPack.name
        },
        sibling: false
      }
    );

    // Create answer block and focus on it
    const answerBlock = await logseq.Editor.insertBlock(
      questionBlock.uuid,
      '답변: ',
      { sibling: false }
    );

    // Set up listener for answer completion
    this.waitForAnswer(answerBlock.uuid, parentUuid, questionPack, questionIndex, previousAnswers);
  }

  private waitForAnswer(
    answerUuid: string,
    parentUuid: string,
    questionPack: QuestionPack,
    questionIndex: number,
    previousAnswers: string[]
  ) {
    // Set up a periodic check for answer completion
    const checkAnswer = async () => {
      const answerBlock = await logseq.Editor.getBlock(answerUuid);
      const content = answerBlock?.content || '';
      
      // Check if answer has substance (more than just "답변: ")
      if (content.replace('답변:', '').trim().length > 3) {
        const answer = content.replace('답변:', '').trim();
        const newAnswers = [...previousAnswers, answer];
        
        // Ask next question
        setTimeout(() => {
          this.askNextQuestion(parentUuid, questionPack, questionIndex + 1, newAnswers);
        }, 1000);
        
        return true; // Stop checking
      }
      
      // Continue checking if no substantial answer yet
      setTimeout(checkAnswer, 2000);
      return false;
    };

    // Start checking after a short delay
    setTimeout(checkAnswer, 2000);
  }

  private async completeQuestionFlow(
    parentUuid: string,
    questionPack: QuestionPack,
    answers: string[]
  ) {
    // Update parent block status
    await logseq.Editor.upsertBlockProperty(parentUuid, 'seed-status', 'developed');
    await logseq.Editor.upsertBlockProperty(parentUuid, 'seed-stage', 'define');

    // Generate completion summary if available
    if (questionPack.onComplete) {
      const summary = questionPack.onComplete(answers);
      
      await logseq.Editor.insertBlock(
        parentUuid,
        summary,
        {
          properties: {
            'seed-analysis': questionPack.name,
            'seed-completed': new Date().toISOString()
          },
          sibling: false
        }
      );
    }

    // Show completion message
    logseq.UI.showMsg(
      `✅ ${questionPack.name} 분석이 완료되었습니다!`,
      'success'
    );

    // Suggest next steps
    setTimeout(() => {
      this.suggestNextSteps(parentUuid);
    }, 2000);
  }

  private async suggestNextSteps(blockUuid: string) {
    logseq.UI.showMsg(
      '🚀 다음 단계를 추천합니다:',
      'info',
      {
        actions: [
          {
            label: '프로젝트 생성',
            onClick: () => this.createProject(blockUuid)
          },
          {
            label: '더 많은 질문',
            onClick: () => this.addMoreQuestions(blockUuid)
          },
          {
            label: '관련 아이디어 찾기',
            onClick: () => this.findRelatedIdeas(blockUuid)
          }
        ]
      }
    );
  }

  private async createProject(seedUuid: string) {
    const { ProjectTemplates } = await import('./templates');
    const templates = new ProjectTemplates();
    await templates.createProjectFromSeed(seedUuid);
  }

  private async addMoreQuestions(seedUuid: string) {
    // Show framework selection dialog
    const frameworks = Array.from(this.questionPacks.keys());
    
    // For now, cycle through frameworks
    const currentFramework = logseq.settings?.questionFramework || 'JTBD';
    const nextFramework = frameworks[(frameworks.indexOf(currentFramework) + 1) % frameworks.length];
    
    const block = await logseq.Editor.getBlock(seedUuid);
    const nextPack = this.questionPacks.get(nextFramework);
    
    if (nextPack) {
      await this.askNextQuestion(seedUuid, nextPack, 0, []);
    }
  }

  private async findRelatedIdeas(seedUuid: string) {
    const block = await logseq.Editor.getBlock(seedUuid);
    const keywords = this.extractKeywords(block.content);
    
    // Simple keyword-based search
    const related = await logseq.DB.q(`
      [:find (pull ?b [*])
       :where
       [?b :block/content ?content]
       [?b :block/properties ?props]
       [(get ?props :seed-status) ?status]
       [(re-find #"${keywords.join('|')}" ?content)]]
    `);

    if (related.length > 1) { // Exclude self
      await logseq.Editor.insertBlock(
        seedUuid,
        `## 관련 아이디어들`,
        { sibling: false }
      );

      for (const relatedBlock of related) {
        if (relatedBlock.uuid !== seedUuid) {
          await logseq.Editor.insertBlock(
            seedUuid,
            `- ((${relatedBlock.uuid}))`,
            { sibling: false }
          );
        }
      }
    }
  }

  private extractKeywords(content: string): string[] {
    // Simple keyword extraction (can be improved with NLP)
    const words = content
      .replace(/#\w+/g, '') // Remove tags
      .replace(/[^\w\s가-힣]/g, ' ') // Keep only words and Korean
      .split(/\s+/)
      .filter(word => word.length > 2);
    
    return [...new Set(words)].slice(0, 5); // Return unique words, max 5
  }
}