import '@logseq/libs';
import { AdvancedMethodologies, QuantityToQuality } from './methodologies';

interface QuestionPack {
  name: string;
  questions: string[] | ((_previousAnswer?: string, _depth?: number) => string);
  onComplete?: (_answers: string[]) => string;
  maxDepth?: number;
}

export class QuestionFramework {
  private questionPacks: Map<string, QuestionPack> = new Map();
  private advancedMethodologies: AdvancedMethodologies;
  private quantityChecker: QuantityToQuality;

  constructor() {
    this.initializeQuestionPacks();
    this.advancedMethodologies = new AdvancedMethodologies();
    this.quantityChecker = new QuantityToQuality();
  }

  private initializeQuestionPacks() {
    this.questionPacks.set('JTBD', {
      name: 'Jobs to be Done',
      questions: [
        "ì´ ì•„ì´ë””ì–´ëŠ” ëˆ„êµ¬ë¥¼ ìœ„í•œ ê±´ê°€ìš”?",
        "ì–´ë–¤ ìƒí™©ì—ì„œ í•„ìš”í•œ ê±´ê°€ìš”?", 
        "ì„±ê³µì€ ì–´ë–»ê²Œ ì¸¡ì •í•  ìˆ˜ ìžˆì„ê¹Œìš”?"
      ],
      onComplete: (answers) => {
        return `## Jobs to be Done Analysis
- **íƒ€ê²Ÿ ì‚¬ìš©ìž**: ${answers[0]}
- **ì‚¬ìš© ìƒí™©**: ${answers[1]}
- **ì„±ê³µ ì§€í‘œ**: ${answers[2]}

*Generated by Seed Plugin*`;
      }
    });

    this.questionPacks.set('FiveWhys', {
      name: 'Five Whys',
      questions: (previousAnswer?: string, depth?: number) => {
        if (depth === 0) return "ì™œ ì´ ë¬¸ì œê°€ ë°œìƒí•˜ë‚˜ìš”?";
        const preview = previousAnswer?.slice(0, 30) + '...';
        return `"${preview}" â†’ ì™œ ê·¸ëŸ°ê°€ìš”?`;
      },
      maxDepth: 5,
      onComplete: (answers) => {
        let result = '## Five Whys Analysis\n';
        answers.forEach((answer, index) => {
          result += `${index + 1}. **Why**: ${answer}\n`;
        });
        result += '\n*Root cause analysis completed*';
        return result;
      }
    });

    this.questionPacks.set('SCAMPER', {
      name: 'SCAMPER Method',
      questions: [
        "**Substitute**: ë¬´ì—‡ì„ ëŒ€ì²´í•  ìˆ˜ ìžˆì„ê¹Œìš”?",
        "**Combine**: ë¬´ì—‡ê³¼ ê²°í•©í•  ìˆ˜ ìžˆì„ê¹Œìš”?",
        "**Adapt**: ë¬´ì—‡ì— ì ìš©í•  ìˆ˜ ìžˆì„ê¹Œìš”?",
        "**Modify**: ì–´ë–»ê²Œ ìˆ˜ì •/í™•ëŒ€í•  ìˆ˜ ìžˆì„ê¹Œìš”?",
        "**Put to other use**: ë‹¤ë¥¸ ìš©ë„ëŠ” ë¬´ì—‡ì¼ê¹Œìš”?",
        "**Eliminate**: ë¬´ì—‡ì„ ì œê±°/ë‹¨ìˆœí™”í•  ìˆ˜ ìžˆì„ê¹Œìš”?",
        "**Reverse**: ë°˜ëŒ€ë¡œ í•˜ë©´ ì–´ë–¨ê¹Œìš”?"
      ],
      onComplete: (answers) => {
        return `## SCAMPER Analysis
${answers.map((answer, i) => {
  const letters = ['S', 'C', 'A', 'M', 'P', 'E', 'R'];
  return `- **${letters[i]}**: ${answer}`;
}).join('\n')}

*Creative exploration completed*`;
      }
    });
  }

  async startQuestionFlow(block: any) {
    // Check for quantity-to-quality upgrade first
    const qualityUpgrade = await this.quantityChecker.checkForQualityUpgrade(block.uuid);
    if (qualityUpgrade) return;

    // Smart methodology selection
    const suggestedFramework = this.advancedMethodologies.getMethodologyForContext(
      block.content, 
      block.properties
    );
    
    const framework = logseq.settings?.questionFramework === 'Auto' 
      ? suggestedFramework 
      : (logseq.settings?.questionFramework || 'JTBD');

    // Try advanced methodologies first
    const methodology = this.advancedMethodologies.getMethodology(framework);
    if (methodology) {
      await this.startAdvancedQuestionFlow(block, methodology);
      return;
    }

    // Fallback to basic question packs
    const questionPack = this.questionPacks.get(framework);
    if (!questionPack) {
      logseq.UI.showMsg('ì•Œ ìˆ˜ ì—†ëŠ” ì§ˆë¬¸ í”„ë ˆìž„ì›Œí¬ìž…ë‹ˆë‹¤.', 'error');
      return;
    }

    await logseq.Editor.upsertBlockProperty(block.uuid, 'seed-status', 'questioning');
    await logseq.Editor.upsertBlockProperty(block.uuid, 'seed-framework', framework);
    await this.askNextQuestion(block.uuid, questionPack, 0, []);
  }

  private async startAdvancedQuestionFlow(block: any, methodology: any) {
    await logseq.Editor.upsertBlockProperty(block.uuid, 'seed-status', 'questioning');
    await logseq.Editor.upsertBlockProperty(block.uuid, 'seed-methodology', methodology.name);
    await logseq.Editor.upsertBlockProperty(block.uuid, 'seed-stage', methodology.stages[0]);

    // Start with first stage questions
    const questions = typeof methodology.questions.questions === 'function' 
      ? methodology.questions.questions({ currentStage: 0 })
      : methodology.questions.questions;

    await this.askAdvancedQuestion(block.uuid, methodology, 0, 0, []);
  }

  private async askAdvancedQuestion(
    parentUuid: string,
    methodology: any,
    stageIndex: number,
    questionIndex: number,
    stageAnswers: string[]
  ) {
    const questions = typeof methodology.questions.questions === 'function'
      ? methodology.questions.questions({ currentStage: stageIndex })
      : methodology.questions.questions;

    if (questionIndex >= questions.length) {
      // Move to next stage or complete
      if (stageIndex + 1 < methodology.stages.length) {
        await this.askAdvancedQuestion(parentUuid, methodology, stageIndex + 1, 0, []);
      } else {
        await this.completeAdvancedFlow(parentUuid, methodology, stageAnswers);
      }
      return;
    }

    const question = questions[questionIndex];
    const stageName = methodology.stages[stageIndex];

    const questionBlock = await logseq.Editor.insertBlock(
      parentUuid,
      `#seed/question **${stageName}**: ${question}`,
      {
        properties: {
          'seed-methodology': methodology.name,
          'seed-stage': stageName,
          'seed-question-index': `${stageIndex}-${questionIndex}`
        },
        sibling: false
      }
    );

    const answerBlock = await logseq.Editor.insertBlock(
      questionBlock.uuid,
      'ë‹µë³€: ',
      { sibling: false }
    );

    this.waitForAdvancedAnswer(answerBlock.uuid, parentUuid, methodology, stageIndex, questionIndex, stageAnswers);
  }

  private waitForAdvancedAnswer(
    answerUuid: string,
    parentUuid: string,
    methodology: any,
    stageIndex: number,
    questionIndex: number,
    stageAnswers: string[]
  ) {
    const checkAnswer = async () => {
      const answerBlock = await logseq.Editor.getBlock(answerUuid);
      const content = answerBlock?.content || '';
      
      if (content.replace('ë‹µë³€:', '').trim().length > 3) {
        const answer = content.replace('ë‹µë³€:', '').trim();
        const newStageAnswers = [...stageAnswers, answer];
        
        setTimeout(() => {
          this.askAdvancedQuestion(parentUuid, methodology, stageIndex, questionIndex + 1, newStageAnswers);
        }, 1000);
        
        return true;
      }
      
      setTimeout(checkAnswer, 2000);
      return false;
    };

    setTimeout(checkAnswer, 2000);
  }

  private async completeAdvancedFlow(parentUuid: string, methodology: any, allAnswers: string[]) {
    await logseq.Editor.upsertBlockProperty(parentUuid, 'seed-status', 'developed');
    
    if (methodology.onComplete) {
      const summary = methodology.onComplete(allAnswers);
      await logseq.Editor.insertBlock(
        parentUuid,
        summary,
        {
          properties: {
            'seed-analysis': methodology.name,
            'seed-completed': new Date().toISOString()
          },
          sibling: false
        }
      );
    }

    // Suggest next methodologies
    const suggestions = await this.advancedMethodologies.suggestNextMethodology(
      methodology.name, 
      await logseq.Editor.getBlock(parentUuid)
    );

    if (suggestions.length > 0) {
      logseq.UI.showMsg(
        `âœ… ${methodology.name} ì™„ë£Œ! ë‹¤ìŒ ë°©ë²•ë¡ ì„ ì¶”ì²œí•©ë‹ˆë‹¤:`,
        'info',
        {
          actions: suggestions.map(method => ({
            label: method,
            onClick: () => this.startMethodology(parentUuid, method)
          }))
        }
      );
    }
  }

  private async startMethodology(seedUuid: string, methodologyName: string) {
    const methodology = this.advancedMethodologies.getMethodology(methodologyName);
    if (methodology) {
      const block = await logseq.Editor.getBlock(seedUuid);
      await this.startAdvancedQuestionFlow(block, methodology);
    }
  }

  private async askNextQuestion(
    parentUuid: string, 
    questionPack: QuestionPack, 
    questionIndex: number, 
    previousAnswers: string[]
  ) {
    let question: string;
    
    if (Array.isArray(questionPack.questions)) {
      if (questionIndex >= questionPack.questions.length) {
        // All questions answered, complete the framework
        await this.completeQuestionFlow(parentUuid, questionPack, previousAnswers);
        return;
      }
      question = questionPack.questions[questionIndex];
    } else {
      if (questionPack.maxDepth && questionIndex >= questionPack.maxDepth) {
        await this.completeQuestionFlow(parentUuid, questionPack, previousAnswers);
        return;
      }
      const lastAnswer = previousAnswers[previousAnswers.length - 1];
      question = questionPack.questions(lastAnswer, questionIndex);
    }

    // Create question block
    const questionBlock = await logseq.Editor.insertBlock(
      parentUuid,
      `#seed/question ${question}`,
      {
        properties: {
          'seed-question-type': questionPack.name,
          'seed-question-index': questionIndex.toString(),
          'seed-question-framework': questionPack.name
        },
        sibling: false
      }
    );

    // Create answer block and focus on it
    const answerBlock = await logseq.Editor.insertBlock(
      questionBlock.uuid,
      'ë‹µë³€: ',
      { sibling: false }
    );

    // Set up listener for answer completion
    this.waitForAnswer(answerBlock.uuid, parentUuid, questionPack, questionIndex, previousAnswers);
  }

  private waitForAnswer(
    answerUuid: string,
    parentUuid: string,
    questionPack: QuestionPack,
    questionIndex: number,
    previousAnswers: string[]
  ) {
    // Set up a periodic check for answer completion
    const checkAnswer = async () => {
      const answerBlock = await logseq.Editor.getBlock(answerUuid);
      const content = answerBlock?.content || '';
      
      // Check if answer has substance (more than just "ë‹µë³€: ")
      if (content.replace('ë‹µë³€:', '').trim().length > 3) {
        const answer = content.replace('ë‹µë³€:', '').trim();
        const newAnswers = [...previousAnswers, answer];
        
        // Ask next question
        setTimeout(() => {
          this.askNextQuestion(parentUuid, questionPack, questionIndex + 1, newAnswers);
        }, 1000);
        
        return true; // Stop checking
      }
      
      // Continue checking if no substantial answer yet
      setTimeout(checkAnswer, 2000);
      return false;
    };

    // Start checking after a short delay
    setTimeout(checkAnswer, 2000);
  }

  private async completeQuestionFlow(
    parentUuid: string,
    questionPack: QuestionPack,
    answers: string[]
  ) {
    // Update parent block status
    await logseq.Editor.upsertBlockProperty(parentUuid, 'seed-status', 'developed');
    await logseq.Editor.upsertBlockProperty(parentUuid, 'seed-stage', 'define');

    // Generate completion summary if available
    if (questionPack.onComplete) {
      const summary = questionPack.onComplete(answers);
      
      await logseq.Editor.insertBlock(
        parentUuid,
        summary,
        {
          properties: {
            'seed-analysis': questionPack.name,
            'seed-completed': new Date().toISOString()
          },
          sibling: false
        }
      );
    }

    // Show completion message
    logseq.UI.showMsg(
      `âœ… ${questionPack.name} ë¶„ì„ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!`,
      'success'
    );

    // Suggest next steps
    setTimeout(() => {
      this.suggestNextSteps(parentUuid);
    }, 2000);
  }

  private async suggestNextSteps(blockUuid: string) {
    logseq.UI.showMsg(
      'ðŸš€ ë‹¤ìŒ ë‹¨ê³„ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤:',
      'info',
      {
        actions: [
          {
            label: 'í”„ë¡œì íŠ¸ ìƒì„±',
            onClick: () => this.createProject(blockUuid)
          },
          {
            label: 'ë” ë§Žì€ ì§ˆë¬¸',
            onClick: () => this.addMoreQuestions(blockUuid)
          },
          {
            label: 'ê´€ë ¨ ì•„ì´ë””ì–´ ì°¾ê¸°',
            onClick: () => this.findRelatedIdeas(blockUuid)
          }
        ]
      }
    );
  }

  private async createProject(seedUuid: string) {
    const { ProjectTemplates } = await import('./templates');
    const templates = new ProjectTemplates();
    await templates.createProjectFromSeed(seedUuid);
  }

  private async addMoreQuestions(seedUuid: string) {
    const frameworks = Array.from(this.questionPacks.keys());
    const currentFramework = logseq.settings?.questionFramework || 'JTBD';
    const nextFramework = frameworks[(frameworks.indexOf(currentFramework) + 1) % frameworks.length];
    
    const nextPack = this.questionPacks.get(nextFramework);
    
    if (nextPack) {
      await this.askNextQuestion(seedUuid, nextPack, 0, []);
    }
  }

  private async findRelatedIdeas(seedUuid: string) {
    const block = await logseq.Editor.getBlock(seedUuid);
    const keywords = this.extractKeywords(block.content);
    
    // Simple keyword-based search
    const related = await logseq.DB.q(`
      [:find (pull ?b [*])
       :where
       [?b :block/content ?content]
       [?b :block/properties ?props]
       [(get ?props :seed-status) ?status]
       [(re-find #"${keywords.join('|')}" ?content)]]
    `);

    if (related.length > 1) { // Exclude self
      await logseq.Editor.insertBlock(
        seedUuid,
        `## ê´€ë ¨ ì•„ì´ë””ì–´ë“¤`,
        { sibling: false }
      );

      for (const relatedBlock of related) {
        if (relatedBlock.uuid !== seedUuid) {
          await logseq.Editor.insertBlock(
            seedUuid,
            `- ((${relatedBlock.uuid}))`,
            { sibling: false }
          );
        }
      }
    }
  }

  private extractKeywords(content: string): string[] {
    // Simple keyword extraction (can be improved with NLP)
    const words = content
      .replace(/#\w+/g, '') // Remove tags
      .replace(/[^\w\sê°€-íž£]/g, ' ') // Keep only words and Korean
      .split(/\s+/)
      .filter(word => word.length > 2);
    
    return [...new Set(words)].slice(0, 5); // Return unique words, max 5
  }
}