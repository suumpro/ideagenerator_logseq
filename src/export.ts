import '@logseq/libs';

export interface ExportOptions {
  format: 'markdown' | 'json' | 'csv' | 'html';
  includeMetadata: boolean;
  includeAnalysis: boolean;
  dateRange?: { start: Date; end: Date };
}

export class SeedExporter {
  async exportToMarkdown(seedUuid: string): Promise<string> {
    const seedBlock = await logseq.Editor.getBlock(seedUuid);
    if (!seedBlock) throw new Error('Seed block not found');

    const tree = await logseq.Editor.getBlockTree(seedUuid);
    const markdown = this.blockTreeToMarkdown(tree, 0);
    
    return `# Seed Export
**Exported**: ${new Date().toLocaleString('ko-KR')}
**Original Block**: ((${seedUuid}))

---

${markdown}

---
*Exported from LogSeq Seed Plugin*`;
  }

  async exportProjectSummary(projectPageName: string): Promise<string> {
    const page = await logseq.Editor.getPage(projectPageName);
    if (!page) throw new Error('Project page not found');

    const blocks = await logseq.Editor.getPageBlocksTree(projectPageName);
    const markdown = blocks.map(block => this.blockTreeToMarkdown(block, 0)).join('\n\n');

    return `# Project Summary: ${projectPageName}
**Exported**: ${new Date().toLocaleString('ko-KR')}

${markdown}

---
*Generated by LogSeq Seed Plugin*`;
  }

  private blockTreeToMarkdown(block: any, depth: number): string {
    const indent = '  '.repeat(depth);
    const content = block.content
      .replace(/\(\([^)]+\)\)/g, '[Block Reference]') // Replace block refs
      .replace(/#\w+/g, (tag) => `\`${tag}\``) // Format tags
      .trim();

    let result = depth === 0 ? content : `${indent}- ${content}`;

    if (block.children && block.children.length > 0) {
      const childrenMd = block.children
        .map((child: any) => this.blockTreeToMarkdown(child, depth + 1))
        .join('\n');
      result += '\n' + childrenMd;
    }

    return result;
  }

  async exportGardenOverview(): Promise<string> {
    const allSeeds = await this.getAllSeeds();
    
    const byStatus = this.groupByStatus(allSeeds);
    const byStage = this.groupByStage(allSeeds);
    
    return `# üå± Seed Garden Overview
**Generated**: ${new Date().toLocaleString('ko-KR')}
**Total Seeds**: ${allSeeds.length}

## üìä Status Distribution
${Object.entries(byStatus).map(([status, seeds]) => 
  `- **${status}**: ${seeds.length} seeds`
).join('\n')}

## üöÄ Development Stages
${Object.entries(byStage).map(([stage, seeds]) => 
  `- **${stage}**: ${seeds.length} seeds`
).join('\n')}

## üåü Recent Seeds (Last 7 days)
${this.getRecentSeeds(allSeeds, 7).map(seed => 
  `- ${seed.content.replace('#seed/idea', '').trim()}`
).join('\n')}

## üèÜ Completed Projects
${allSeeds
  .filter(s => s.properties?.['seed-status'] === 'project')
  .map(s => `- ${s.content.replace('#seed/idea', '').trim()}`)
  .join('\n') || '- No projects yet'}

---
*Report generated by LogSeq Seed Plugin*`;
  }

  private async getAllSeeds() {
    return await logseq.DB.q(`
      [:find (pull ?b [*])
       :where 
       [?b :block/properties ?props]
       [(get ?props :seed-status) ?status]]
    `);
  }

  private groupByStatus(seeds: any[]) {
    return seeds.reduce((acc, seed) => {
      const status = seed.properties?.['seed-status'] || 'unknown';
      if (!acc[status]) acc[status] = [];
      acc[status].push(seed);
      return acc;
    }, {});
  }

  private groupByStage(seeds: any[]) {
    return seeds.reduce((acc, seed) => {
      const stage = seed.properties?.['seed-stage'] || 'unknown';
      if (!acc[stage]) acc[stage] = [];
      acc[stage].push(seed);
      return acc;
    }, {});
  }

  private getRecentSeeds(seeds: any[], days: number) {
    const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
    return seeds.filter(seed => {
      const created = seed.properties?.['seed-created'];
      return created && new Date(created) > cutoff;
    });
  }

  async createBackup() {
    const allSeeds = await this.getAllSeeds();
    const backup = {
      exported: new Date().toISOString(),
      version: '0.2.0',
      pluginVersion: '0.2.0',
      totalSeeds: allSeeds.length,
      seeds: allSeeds.map(seed => ({
        uuid: seed.uuid,
        content: seed.content,
        properties: seed.properties,
        page: seed.page?.name,
        created: seed['created-at'],
        updated: seed['updated-at'],
        children: seed.children?.map((child: any) => ({
          uuid: child.uuid,
          content: child.content,
          properties: child.properties
        })) || []
      }))
    };

    const backupJson = JSON.stringify(backup, null, 2);
    
    const blob = new Blob([backupJson], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `seed-backup-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);

    logseq.UI.showMsg(`üå± ${allSeeds.length}Í∞ú Seed Î∞±ÏóÖÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!`, 'success');
  }

  async exportToCSV(): Promise<string> {
    const allSeeds = await this.getAllSeeds();
    
    const headers = ['ID', 'Content', 'Status', 'Stage', 'Created', 'Last Activity', 'Page', 'Methodology'];
    const rows = allSeeds.map(seed => [
      seed.properties?.['seed-id'] || seed.uuid,
      seed.content.replace('#seed/idea', '').trim().replace(/"/g, '""'),
      seed.properties?.['seed-status'] || '',
      seed.properties?.['seed-stage'] || '',
      seed.properties?.['seed-created'] || '',
      seed.properties?.['seed-last-activity'] || '',
      seed.page?.name || '',
      seed.properties?.['seed-methodology'] || ''
    ]);

    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
    ].join('\n');

    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `seeds-export-${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    URL.revokeObjectURL(url);

    return csvContent;
  }

  async exportFilteredSeeds(filter: (seed: any) => boolean, filename?: string): Promise<string> {
    const allSeeds = await this.getAllSeeds();
    const filteredSeeds = allSeeds.filter(filter);
    
    const exportData = {
      exported: new Date().toISOString(),
      filter: 'Custom Filter Applied',
      count: filteredSeeds.length,
      seeds: filteredSeeds.map(seed => ({
        content: seed.content,
        properties: seed.properties,
        analysis: this.extractAnalysisFromSeed(seed)
      }))
    };

    const jsonContent = JSON.stringify(exportData, null, 2);
    
    if (filename) {
      const blob = new Blob([jsonContent], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    return jsonContent;
  }

  private extractAnalysisFromSeed(seed: any): any {
    return {
      hasQuestions: seed.children?.some((c: any) => c.content.includes('#seed/question')) || false,
      answerCount: seed.children?.filter((c: any) => c.content.includes('ÎãµÎ≥Ä:')).length || 0,
      methodology: seed.properties?.['seed-methodology'],
      clustered: !!seed.properties?.['seed-cluster'],
      validated: !!seed.properties?.['seed-validation-plan']
    };
  }
}